---
title: "DNA methylation Illumina Mouse Array Quality Control Report"
author: "Emma Walker"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---


```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r setup, include=FALSE}

args<-commandArgs(trailingOnly = TRUE)

#projDir <- args[1]
dataDir <- "/lustre/projects/Research_Project-MRC190311/DNAm/circadianMouse/Albert"



library(ENmix) # #https://www.bioconductor.org/packages/devel/bioc/vignettes/ENmix/inst/doc/ENmix.pdf 
library(ggplot2)
library(dplyr)
library(minfi)
library(gridExtra)
library(corrplot)


setwd(dataDir)

pheno <- file.path(dataDir, "0_metadata/sampleSheet.csv")
normDir <- file.path(dataDir, "2_normalised")
QCDir <- file.path(normDir, "QC")


source(file.path(dataDir,"config.r"))


#load sampleSheet
sampleSheet <- read.csv(pheno, stringsAsFactors = F)

```

# Introduction

QC report for Mouse Data

Pipeline updated October 2024


# Loading data

An object of class ENmix::rgDataSet was made using the ENmix package and is loaded in alongside the sample sheet containing the pheno data for the mice, and QCmetrics object created by the calcMouseMethQCmetrics.r script


```{r, load QCmetrics,  warning=FALSE, message=FALSE, echo = FALSE}


load(file = file.path(QCDir, "rgSet.rdat"))
load(file = file.path(QCDir, "QCmetrics.rdat"))
load(file = file.path(QCDir, "detP.rdat"))
load(file = file.path(QCDir, "bsCon.rdat"))
load(file = file.path(QCDir, "detP.rdat"))
load(file = file.path(QCDir, "mraw.rdat"))

betas <- getB(mraw)


# add column for neun and non neun celltypes
if(ctCheck){
  QCmetrics$NeuN <- ifelse(QCmetrics$Cell_Type == "NEUN", "NEUN", "OTHER")
}

```

# Intensity check

The intensity check is often the biggest indicator of sample quality. The median methylated signal intensity and unmethylated signal intensity for each sample is calculated.

`r sum(!QCmetrics$IntensityPass)` samples fail at an intensity threshold of `r intensThresh`


# Intensity plots

```{r plotintensities, echo=FALSE, message=F}


ggplot(QCmetrics, aes(x = M.median, y = U.median, colour = Individual_ID)) +
   geom_point() +
   xlab("Median M intensity") +
   ylab("Median U intensity") +
   ggtitle("Signal Intensities by Individual_ID")

if("Age" %in% colnames(QCmetrics)){
ggplot(QCmetrics, aes(x = M.median, y = U.median, colour = Age)) +
  geom_point() +
  xlab("Median M intensity") +
  ylab("Median U intensity") +
  ggtitle("Signal Intensities by age")
}

if("Cell_Type" %in% colnames(QCmetrics)){
ggplot(QCmetrics, aes(x = M.median, y = U.median, colour = Cell_Type))+
  geom_point()+
  xlab("Median M intensity")+
  ylab("Median U intensity") + 
  ggtitle("Signal Intensities by Cell Type")
}

if("Sex" %in% colnames(QCmetrics)){
ggplot(QCmetrics, aes(x = M.median, y = U.median, colour = Sex))+
  geom_point()+
  xlab("Median M intensity")+
  ylab("Median U intensity") + 
  ggtitle("Signal Intensities by sex")
}

ggplot(QCmetrics, aes(x = M.median, y = U.median, colour = gsub("_.*", "", Basename))) +
  geom_point() +
  xlab("Median M intensity") +
  ylab("Median U intensity") +
  ggtitle("Signal Intensities by Chip")

if("Nuclei_Conc" %in% colnames(QCmetrics)){
ggplot(QCmetrics, aes(x = M.median, y = U.median, colour = Nuclei_Conc)) +
  geom_point() +
  xlab("Median M intensity") +
  ylab("Median U intensity") +
  ggtitle("Signal Intensities by Nuclei Conc")
}

if("Batch" %in% colnames(QCmetrics)){
ggplot(QCmetrics, aes(x = M.median, y = U.median, colour = Batch)) +
  geom_point() +
  xlab("Median M intensity") +
  ylab("Median U intensity") +
  ggtitle("Signal Intensities by Batch")
}


```

# P filter 

```{r, pfilt, echo=FALSE}

failedProbes <- rownames(detP)[((rowSums(detP > pFiltProbeThresh)/ncol(detP)) * 100) > pFiltSampleThresh]

```

`r length(failedProbes)` probes fail at a pvalue threshold of `r pFiltProbeThresh` in more than `r pFiltSampleThresh`% of samples




```{r heatmaps, echo=FALSE, message=F}

QCmetrics$IntensityRatio <- QCmetrics$M.median/QCmetrics$U.median # previously M - U
QCmetrics$SentrixPosition <- factor(QCmetrics$Chip_Position)
QCmetrics$SentrixID <- factor(gsub("_.*", "", QCmetrics$Basename), levels=rev(unique(gsub("_.*", "", QCmetrics$Basename)))) #keeps the levels of the factor in current order rather than sorting numerically/alphabetically, also reverses this order as heatmaps plot bottom to top

#extract the legend (using a function found online)
g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  legend
}


plateHeatmap <- ggplot(data=QCmetrics, aes(x=SentrixPosition, y=SentrixID)) +
  scale_fill_gradientn(colours=colorRamps::matlab.like(100), limits=c(min(QCmetrics$U.median, QCmetrics$M.median),max(QCmetrics$U.median, QCmetrics$M.median))) +
  labs(x="", y="") +
  theme_minimal() + 
  coord_equal() +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 90, hjust=1))

plot1 <- plateHeatmap +
  ggtitle("Median Methylated Intensity") +
  geom_tile(aes(fill=M.median), colour = "white") +
  theme(legend.position = "none")

plot2 <- plateHeatmap +
  ggtitle("Median Unmethylated Intensity") +
  geom_tile(aes(fill=U.median), colour = "white") +
  theme(legend.position = "none")

legendplot <- plateHeatmap + 
  geom_tile(aes(fill=U.median), colour = "white") +
  labs(fill="Intensity", alpha="Control") +
  scale_alpha_manual(values=c(1,1,1)) + 
  guides(alpha = guide_legend(override.aes = list(colour="black", pch=16)))

legend <- g_legend(legendplot)

chip_heatmaps <- grid.arrange(plot1, plot2, legend, ncol=3, widths=c(3/7, 3/7, 1/7))
ggsave("Methylation_intensity_CHIP.png", chip_heatmaps, device = "png")

###################
```

# Bisulphite Conversion

```{r bisulphiteconversion, echo=FALSE}

ggplot(QCmetrics, aes(x = BsCon))+
  geom_histogram()+
  geom_vline(xintercept=bsConThresh, colour = "red", linetype="dashed")


```

`r sum(!QCmetrics$BsConPass)` samples fail at an intensity threshold of `r bsConThresh`



# Density Plots

```{r density plots, echo = FALSE, message = F}

betas <- betas[, QCmetrics$Basename]

densityPlot(betas, main = "All Betas")
densityPlot(betas, main = "Passed Samples", sampGroups = QCmetrics$PassQC1)

```



# Correlations between QC metrics

```{r, echo = FALSE, fig.width = 10, fig.height = 10}

colsToKeep <- c(c(c("M.median","U.median","BsCon", "pFiltPass", "Cell_Type", "Batch", "DummyGroup",
                    "Age","Sex", "Pathology"),
                  colnames(QCmetrics)[grep("PC", colnames(QCmetrics))]))

colsToKeep <- colsToKeep[colsToKeep %in% colnames(QCmetrics)]

corDF <- QCmetrics[,colsToKeep]

# change to correct type
if(ctCheck){corDF$Cell_Type <- as.numeric(as.factor(corDF$Cell_Type))}
if("Batch" %in% colnames(sampleSheet)){
  corDF$Batch <- as.numeric(as.factor(corDF$Batch))
}
if("Sex" %in% colnames(sampleSheet)){
  corDF$Sex <- as.numeric(as.factor(corDF$Sex))
}

corrplot::corrplot(cor(corDF, use = "p"))

```


```{r, child=if (sexCheck) 'rmarkdownChild/sexCheck.rmd'}
```


```{r, child=if (ctCheck) 'rmarkdownChild/ctCheck.rmd'}
```